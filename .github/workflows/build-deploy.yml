name: build-deploy
on:
  push:
    branches: [ "main" ]
    paths:
      - "apps/**"
      - "arch/registry/**"
      - "modules/microservice-ecr/**"
  pull_request:
    branches: [ "main" ]
    paths:
      - "apps/**"
      - "arch/registry/**"
      - "modules/microservice-ecr/**"
  workflow_dispatch:
    inputs:
      ref:
        description: "Branch or tag to run against"
        required: false
        default: "main"

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  SHARED_CHART: apps/charts/shared
  DEFAULT_NAMESPACE: vm-apps

jobs:
  reconcile-and-matrix:
    runs-on: ubuntu-latest
    outputs:
      repos_json:     ${{ steps.out.outputs.repos_json }}       # { "vm-poc-frontend": "acct.dkr....../vm-poc-frontend", ... }
      map_json:       ${{ steps.out.outputs.map_json }}         # { "vm-poc-frontend": "frontend", ... }
      repos_list_json: ${{ steps.out.outputs.repos_list_json }}  # [ "vm-poc-frontend", ... ]
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.ref || github.ref }}
          submodules: recursive
          token: ${{ secrets.SUBMODULE_PAT }}
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.CI_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6
      - name: Terraform Apply (fleet)
        working-directory: arch/registry
        run: |
          terraform init -input=false
          terraform apply -auto-approve -input=false

      - name: Read outputs & build matrix
        id: out
        working-directory: arch/registry
        run: |
          python3 - <<'PY'
          import json, subprocess, sys
          def tf_out(name):
              return json.loads(subprocess.check_output(["terraform","output","-json",name], text=True))
          repos = tf_out("repository_urls")   # map: repo_name -> repo_url
          mapping = tf_out("repo_to_service") # map: repo_name -> service_folder
          sys.stdout.write(f"::set-output name=repos_json::{json.dumps(repos)}\n")
          sys.stdout.write(f"::set-output name=map_json::{json.dumps(mapping)}\n")
          sys.stdout.write(f"::set-output name=repos_list_json::{json.dumps(sorted(list(repos.keys())))}\n")
          PY

  build-push:
    name: Build & Push (${{ matrix.repo_name }})
    runs-on: ubuntu-latest
    needs: reconcile-and-matrix
    if: ${{ fromJson(needs.reconcile-and-matrix.outputs.repos_list_json)[0] != null }}
    strategy:
      fail-fast: false
      matrix:
        repo_name: ${{ fromJson(needs.reconcile-and-matrix.outputs.repos_list_json) }}
    env:
      REPOS_JSON: ${{ needs.reconcile-and-matrix.outputs.repos_json }}
      MAP_JSON:   ${{ needs.reconcile-and-matrix.outputs.map_json }}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
          token: ${{ secrets.SUBMODULE_PAT }}
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.CI_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Resolve repo URL and app folder
        id: resolve
        run: |
          python3 - <<'PY'
          import json, os, sys
          repos = json.loads(os.environ["REPOS_JSON"])
          mapping = json.loads(os.environ["MAP_JSON"])
          name = os.environ["MATRIX_REPO"]
          repo_url = repos[name]
          service  = mapping[name]
          print(f"::set-output name=repo_url::{repo_url}")
          print(f"::set-output name=service::{service}")
          PY
        env:
          MATRIX_REPO: ${{ matrix.repo_name }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push image
        id: build
        working-directory: apps/${{ steps.resolve.outputs.service }}/app
        run: |
          IMAGE="${{ steps.resolve.outputs.repo_url }}"
          TAG="latest"
          
          # Special handling for frontend builds that need backend URL at build time
          if [[ "${{ steps.resolve.outputs.service }}" == *"frontend"* ]]; then
            # Extract service name to determine backend service DNS
            SERVICE_NAME="${{ steps.resolve.outputs.service }}"
            if [[ "$SERVICE_NAME" == "vm-poc-frontend-fortiflex-marketplace" ]]; then
              # Build with K8s internal backend DNS
              docker build \
                --build-arg VITE_BACKEND_HOST=http://vm-poc-backend-fortiflex-marketplace:8000 \
                -t "$IMAGE:$TAG" .
            else
              docker build -t "$IMAGE:$TAG" .
            fi
          else
            docker build -t "$IMAGE:$TAG" .
          fi
          
          docker push "$IMAGE:$TAG"
          echo "tag=$TAG" >> $GITHUB_OUTPUT

#  deploy:
#    name: Helm Deploy (${{ matrix.repo_name }})
#    runs-on: ubuntu-latest
#    needs: [reconcile-and-matrix, build-push]
#    if: ${{ fromJson(needs.reconcile-and-matrix.outputs.repos_list_json)[0] != null }}
#    strategy:
#      fail-fast: false
#      matrix:
#        repo_name: ${{ fromJson(needs.reconcile-and-matrix.outputs.repos_list_json) }}
#    env:
#      REPOS_JSON: ${{ needs.reconcile-and-matrix.outputs.repos_json }}
#      MAP_JSON:   ${{ needs.reconcile-and-matrix.outputs.map_json }}
#      SHARED_CHART: ${{ env.SHARED_CHART }}
#      DEFAULT_NAMESPACE: ${{ env.DEFAULT_NAMESPACE }}
#    steps:
#      - uses: actions/checkout@v4
#
#      - name: Install tools
#        run: |
#          sudo apt-get update -y
#          sudo apt-get install -y jq
#          # yq
#          YQ_VER="v4.44.3"
#          wget -q "https://github.com/mikefarah/yq/releases/download/${YQ_VER}/yq_linux_amd64.tar.gz"
#          tar -xzf yq_linux_amd64.tar.gz && sudo mv yq_linux_amd64 /usr/local/bin/yq
#          # kubectl
#          curl -sSL -o kubectl https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
#          chmod +x kubectl && sudo mv kubectl /usr/local/bin/
#          # helm
#          curl -sSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
#
#      - name: Configure kube access
#        run: |
#          echo "${{ secrets.KUBE_CONFIG_B64 }}" | base64 -d > kubeconfig
#          echo "KUBECONFIG=$PWD/kubeconfig" >> $GITHUB_ENV
#          kubectl version --client
#          helm version
#
#      - name: Resolve app folder & repo URL
#        id: resolve
#        run: |
#          python3 - <<'PY'
#import json, os, sys
#repos = json.loads(os.environ["REPOS_JSON"])
#mapping = json.loads(os.environ["MAP_JSON"])
#name = os.environ["MATRIX_REPO"]
#print(f"::set-output name=repo_url::{repos[name]}")
#print(f"::set-output name=service::{mapping[name]}")
#PY
#        env:
#          MATRIX_REPO: ${{ matrix.repo_name }}
#
#      - name: Determine namespace
#        id: ns
#        run: |
#          VALUES="apps/${{ steps.resolve.outputs.service }}/values.yaml"
#          NS=$(yq -r '.namespace // ""' "$VALUES" 2>/dev/null || true)
#          [[ -z "$NS" || "$NS" == "null" ]] && NS="${DEFAULT_NAMESPACE}"
#          echo "namespace=$NS" >> $GITHUB_OUTPUT
#
#      - name: Helm upgrade --install
#        env:
#          KUBECONFIG: ${{ env.KUBECONFIG }}
#        run: |
#          helm upgrade --install "${{ steps.resolve.outputs.service }}" "${SHARED_CHART}" \
#            -n "${{ steps.ns.outputs.namespace }}" --create-namespace \
#            -f "apps/${{ steps.resolve.outputs.service }}/values.yaml" \
#            --set image.repository=${{ steps.resolve.outputs.repo_url }} \
#            --set image.tag=${{ needs.build-push.outputs.tag || github.sha[0:12] }}
#
