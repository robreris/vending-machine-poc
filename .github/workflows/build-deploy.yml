name: build-deploy

on:
  push:
    branches: [ "main" ]
    paths:
      - "apps/**"
      - "arch/registry/**"
      - "modules/microservice-ecr/**"
  pull_request:
    branches: [ "main" ]
    paths:
      - "apps/**"
      - "arch/registry/**"
      - "modules/microservice-ecr/**"
  workflow_dispatch:
    inputs:
      force_delete:
        description: "Allow Terraform to delete ECR repos with images"
        required: false
        default: "false"
        type: choice
        options: [ "false", "true" ]

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  APPS_ROOT: apps
  SHARED_CHART: apps/charts/shared
  DEFAULT_NAMESPACE: vm-apps

jobs:
  discover:
    runs-on: ubuntu-latest
    outputs:
      services_json: ${{ steps.out.outputs.services_json }}
    steps:
      - uses: actions/checkout@v4

      - id: out
        run: |
          set -euo pipefail
          # all first-level dirs under apps/, excluding 'charts'
          #mapfile -t SERVICES < <(find "${APPS_ROOT}" -maxdepth 1 -mindepth 1 -type d -printf "%f\n" | grep -v '^charts$' | sort)
          mapfile -t SERVICES < <(ls apps | grep -v '^charts$' | xargs -I {} cat ${APPS_ROOT}/{}/values.yaml | grep repository | cut -d'/' -f2)
          if [[ ${#SERVICES[@]} -eq 0 ]]; then
            echo "No services found under ${APPS_ROOT}"
            echo '[]' > services.json
          else
            printf '[' > services.json
            for i in "${!SERVICES[@]}"; do
              printf '%s"%s"' "$([[ $i -gt 0 ]] && echo ',')" "${SERVICES[$i]}" >> services.json
            done
            printf ']' >> services.json
          fi
          echo "services_json=$(cat services.json)" >> "$GITHUB_OUTPUT"
          echo "Discovered services: $(cat services.json)"

  reconcile-ecr:
    name: Reconcile ECR repos
    runs-on: ubuntu-latest
    needs: discover
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.CI_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.12.2
      - name: Terraform Apply (fleet)
        working-directory: arch/registry
        env:
          TF_CLI_ARGS_plan: -input=false
          TF_CLI_ARGS_apply: -input=false -auto-approve
        run: |
          sudo apt-get update -y && sudo apt-get install -y jq
          terraform init
          SVCS='${{ needs.discover.outputs.services_json }}'
          FORCE='${{ inputs.force_delete || 'false' }}'
          terraform apply \
            -var="services=$(echo "$SVCS" | jq -cr 'map(.) | unique | .')" \
            -var="force_delete=$FORCE"

      - name: Output ECR map
        id: ecrmap
        working-directory: arch/registry
        run: |
          sudo apt-get install -y jq >/dev/null 2>&1 || true
          terraform output -json repository_urls > repos.json
          echo "repos_json=$(cat repos.json)" >> "$GITHUB_OUTPUT"

  build-push:
    name: Build & Push (${{ matrix.service }})
    runs-on: ubuntu-latest
    needs: [discover, reconcile-ecr]
    if: ${{ fromJson(needs.discover.outputs.services_json)[0] != null }}
    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJson(needs.discover.outputs.services_json) }}
    env:
      SERVICE_DIR: apps/${{ matrix.service }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.CI_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Resolve repo URL
        id: repo
        run: |
          sudo apt-get update -y && sudo apt-get install -y jq
          echo '${{ needs.reconcile-ecr.outputs.repos_json }}' > repos.json || true
          # If outputs aren't available (older Actions behavior), pull from TF state as fallback
          if [[ ! -s repos.json ]]; then
            echo "Falling back to per-service repo URL via AWS CLI"
            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            echo "{\"${{ matrix.service }}\":\"${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ matrix.service }}\"}" > repos.json
          fi
          IMAGE=$(jq -r --arg s "${{ matrix.service }}" '.[$s]' repos.json)
          echo "image_repo=$IMAGE" >> "$GITHUB_OUTPUT"

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push
        id: build
        working-directory: ${{ env.SERVICE_DIR }}
        run: |
          IMAGE="${{ steps.repo.outputs.image_repo }}"
          TAG="${GITHUB_SHA::12}"
          docker build -t "$IMAGE:$TAG" .
          docker push "$IMAGE:$TAG"
          echo "tag=$TAG" >> $GITHUB_OUTPUT

#  deploy:
#    name: Helm Deploy (${{ matrix.service }})
#    runs-on: ubuntu-latest
#    needs: [discover, reconcile-ecr, build-push]
#    if: ${{ fromJson(needs.discover.outputs.services_json)[0] != null }}
#    strategy:
#      fail-fast: false
#      matrix:
#        service: ${{ fromJson(needs.discover.outputs.services_json) }}
#    env:
#      SERVICE: ${{ matrix.service }}
#      SERVICE_DIR: apps/${{ matrix.service }}
#      CHART_PATH: apps/charts/shared
#      DEFAULT_NAMESPACE: ${{ env.DEFAULT_NAMESPACE }}
#    steps:
#      - uses: actions/checkout@v4
#
#      - name: Install tools
#        run: |
#          sudo apt-get update -y
#          sudo apt-get install -y jq
#          # yq
#          YQ_VER="v4.44.3"
#          wget -q "https://github.com/mikefarah/yq/releases/download/${YQ_VER}/yq_linux_amd64.tar.gz"
#          tar -xzf yq_linux_amd64.tar.gz && sudo mv yq_linux_amd64 /usr/local/bin/yq
#          # kubectl
#          curl -sSL -o kubectl https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
#          chmod +x kubectl && sudo mv kubectl /usr/local/bin/
#          # helm
#          curl -sSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
#
#      - name: Configure kube access
#        run: |
#          echo "${{ secrets.KUBE_CONFIG_B64 }}" | base64 -d > kubeconfig
#          echo "KUBECONFIG=$PWD/kubeconfig" >> $GITHUB_ENV
#          kubectl version --client
#          helm version
#
#      - name: Determine namespace
#        id: ns
#        run: |
#          VALUES="${SERVICE_DIR}/values.yaml"
#          NS=$(yq -r '.namespace // ""' "$VALUES" 2>/dev/null || true)
#          [[ -z "$NS" || "$NS" == "null" ]] && NS="${DEFAULT_NAMESPACE}"
#          echo "namespace=$NS" >> $GITHUB_OUTPUT
#          echo "Using namespace: $NS"
#
#      - name: Repo URL for this service
#        id: repo
#        run: |
#          echo '${{ needs.reconcile-ecr.outputs.repos_json }}' > repos.json || true
#          if [[ ! -s repos.json ]]; then
#            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
#            echo "{\"${{ matrix.service }}\":\"${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ matrix.service }}\"}" > repos.json
#          fi
#          IMAGE=$(jq -r --arg s "${{ matrix.service }}" '.[$s]' repos.json)
#          echo "image_repo=$IMAGE" >> "$GITHUB_OUTPUT"
#
#      - name: Image tag from build
#        id: tag
#        run: echo "tag=${GITHUB_SHA::12}" >> $GITHUB_OUTPUT
#
#      - name: Helm upgrade --install
#        env:
#          KUBECONFIG: ${{ env.KUBECONFIG }}
#        run: |
#          helm upgrade --install "${SERVICE}" "${CHART_PATH}" \
#            -n "${{ steps.ns.outputs.namespace }}" --create-namespace \
#            -f "${SERVICE_DIR}/values.yaml" \
#            --set image.repository=${{ steps.repo.outputs.image_repo }} \
#            --set image.tag=${{ steps.tag.outputs.tag }}
